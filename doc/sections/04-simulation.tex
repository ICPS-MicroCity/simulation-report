\section{The Simulation}\label{sec:the-simulation}

In this section, we discuss the main elements of the simulation.
To fully understand the concepts that are discussed here, such as nodes and programs, please refer to the~\href{https://alchemistsimulator.github.io/}{Alchemist documentation}.

\subsection{Map Environment}\label{subsec:map-environment}
The simulation concerns an existing geographical location, that is the amusement park of~\href{https://www.mirabilandia.it/}{\textit{Mirabilandia}}.
For this reason, the environment of the simulation must be a map featuring existing paths in the real world.
To achieve this, \textit{Alchemist} allows using maps provided by \href{https://www.openstreetmap.org/}{\textit{OpenStreetMap}}, the free wiki world map. \textit{OpenStreetMap} provides navigation capabilities on the whole planet;
such data, weighs about 50GB, thus it is recommended to use an extract with the data relative to the interested area.
One great way to obtain an extract is through~\href{https://extract.bbbike.org/}{\textit{BBBike}}~\cite{Pianini_2013}.

Once extracted the map in the \texttt{.pbf} format, it is possible to build the simulation environment through the~\href{https://alchemistsimulator.github.io/reference/kdoc/alchemist/it.unibo.alchemist.model.implementations.environments/-o-s-m-environment/}{\texttt{OSMEnvironment}}, as shown in the following listing (\ref{lst:osm}).

\input{../code/osm}

\noindent
The constructor of the environment accepts two parameters:
\begin{itemize}
    \item \texttt{file: String}, the path to the file containing the exported map;
    \item \texttt{onlyOnStreets: Boolean}, a boolean value allowing to deploy nodes only on the streets.
\end{itemize}

\subsection{Deployed Nodes}\label{subsec:deployed-nodes}
After setting the environment, it is essential to deploy \textbf{nodes} on the map.
In the current simulation, the elements that are represented by nodes are:
\begin{itemize}
    \item \textbf{Visitors}, as single individuals or groups;
    the key point here is that a node should correspond to one or more people using a single wearable device that tracks and guides its owner.
    \item \textbf{Attractions}, that can be of different types, such as rides, water slides, restaurants, etc.; they are considered \textit{rendezvous} points for visitors and are made of several sensors that allow keeping track of various information, such as the number of people waiting in a queue.
\end{itemize}

\noindent
In order to deploy nodes on the map it is mandatory to declare them under the \texttt{deployments} section, as shown in the following listing.

\input{../code/deployments}

\noindent
Moreover, it is necessary to explicit which \textbf{linking rule} will be used to connect nodes with each other.
As for the current simulation, the proper way to connect nodes cannot be based on a geometric rule (for instance, connecting nodes within a certain distance).
Instead, it is appropriate to consider attractions as \textbf{access points} for the visitors' devices.
Even with the~\href{https://alchemistsimulator.github.io/reference/kdoc/alchemist/it.unibo.alchemist.model.implementations.linkingrules/-connect-to-access-point/index.html}{\texttt{ConnectToAccessPoint}} linking rule every node on the map will be connected with the rest of the network as the attractions are distributed throughout the map, and, working as access points, they can cover it without leaving connectionless areas.

\input{../code/linking}

\subsection{Programmed Behaviours}
With both the environment and the nodes correctly set, the next step consists in programming their behaviours.
Each and every node needs to implement a proper behaviour depending on its type.
In particular, visitors and attractions will have different behaviours: for instance, visitors should move on the map in order to get to attractions, while the latter should stay still and satisfy enqueued visitors.
The following sections describe the behaviours implemented by visitors and attractions.

\subsubsection{Attractions' Positions}
In order to make each visitor node aware of the positions of all the attractions in the map, it is necessary to implement a behaviour that spreads the desired information.
To do so, it is useful to use \textit{aggregate programming}.
Specifically, \textit{Alchemist} allows inserting an external program into a node, as shown in the following listing.

\input{../code/positions}

On the other hand, the definition of the aggregate program should describe how the desired information is spread as a field.
In particular, each node should gather the field from its neighbours and merge the received values.
The listing~\ref{lst:protelis-positions} shows how it is possible to implement this behaviour in \textit{Protelis}.

\input{../code/protelis-positions}

The \texttt{attractionPositions} function simply builds a list with the node's position if it presents an ``attraction" molecule, otherwise an empty list.
In this way, the field is composed by lists of positions containing only attractions' coordinates.
The \texttt{attractionUnion} function just unifies the received lists into a single one.

\subsubsection{Queues \& Satisfaction}
Similarly to positions, it is necessary to keep track of the queues that form nearby attractions and broadcast them to visitors.
The queue formed nearby an attraction is determined by the sequence of visitors that have the same coordinates as the attraction.
Though, it is important that the visitors waiting in the queue are not satisfied.
In fact, a visitor's satisfaction is a condition that only occurs after it has benefited from an attraction.
When satisfied, the visitor is then ready to choose the next destination, and, once the next attraction is decided, it can switch back to unsatisfied.
These behaviours can be split into 3 different \textit{Protelis} programs:
\begin{itemize}
  \item \textbf{\texttt{queue}}: given an attraction, determine the list of visitors that are enqueued to it.
  \item \textbf{\texttt{queues}}: broadcast the queues of every attraction to every visitor.
  \item \textbf{\texttt{satisfaction}}: given an attraction, satisfy the first $N$ visitors in its queue, where $N$ represents the attraction's capacity.
\end{itemize}

\noindent
All these behaviours are programmed by both attractions and visitors.
The \texttt{satisfaction} program has a lower time distribution, as it is assumed that it takes a while for an attraction to satisfy visitors.

\subsubsection{Movement}
Movement is a feature only owned by visitors.
It is implemented as a \href{https://alchemistsimulator.github.io/reference/kdoc/alchemist/it.unibo.alchemist.model.implementations.actions/-target-map-walker/index.html}{\texttt{TargetMapWalker}}: this action needs a ``tracking" molecule inside the implementing node that has a destination's coordinates as its concentration.
Moreover, the latter allows nodes to move only on maps' streets, adapting to the provided \href{https://alchemistsimulator.github.io/reference/kdoc/alchemist/it.unibo.alchemist.model.implementations.environments/-o-s-m-environment/}{\texttt{OSMEnvironment}}.

As discussed in the section~\ref{sec:the-case-study}, in order to decide its next destination, a visitor can adopt one of these two policies: \textbf{Random Redirection} or \textbf{Recommended Redirection}.
In order to achieve this, visitors also own a program that establishes the next destination with one of the two policies and inserts its coordinates in a molecule.
The listing~\ref{code:movement} shows how the \texttt{TargetMapWalker} behaviour and the \texttt{destination} behaviour are assigned to the visitor nodes.

\input{../code/movement}

In order to choose the next destination for a visitor, a \textit{Protelis} program will call a function \texttt{getNext} that will return the coordinates of the next attraction.
It is possible to define a custom policy just by implementing the interface \texttt{NextPolicy}, and therefore defining the method \texttt{getNext}.
For the sake of the current simulations, the following policies were provided:
\begin{itemize}
    \item \texttt{RandomPolicy}: performs a \textit{random redirection} by choosing one of the attractions inside the park randomly.
    \item \texttt{ShortestQueuePolicy}: performs a \textit{recommended redirection} by choosing the attraction with the shortest queue inside the whole park.
    \item \texttt{ShortestQueueInRangePolicy}: performs a \textit{recommended redirection} by choosing the attraction with the shortest queue within a given range with regard to the visitor.
\end{itemize}

\subsection{Data Extraction}\label{subsec:data-extraction}
The whole point of the simulations consists in determining whether a \textit{situated recommendation system} may help reduce the waiting time for visitors inside the park.
In order to evaluate that, it is necessary to extract data from the simulation.
In particular, the data we extracted and analyzed concerns the number of attractions that every visitor has benefited from.
This was possible thanks to a specific molecule \texttt{satisfactions} that counts the amount of times that a visitor has been satisfied by an attraction.

