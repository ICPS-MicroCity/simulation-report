\section{The Simulation}

In this section, we discuss the main elements of the simulation. To fully understand the concepts that are discussed here, such as nodes and programs, please refer to the \href{https://alchemistsimulator.github.io/}{Alchemist documentation}.

\subsection{Map Environment}
The simulation concerns an existing geographical location, that is the amusement park of \href{https://www.mirabilandia.it/}{\textit{Mirabilandia}}. For this reason, the environment of the simulation must be a map featuring existing paths in the real world. To achieve this, \textit{Alchemist} allows to use maps provided by \href{https://www.openstreetmap.org/}{\textit{OpenStreetMap}}, the free wiki world map. \textit{OpenStreetMap} provides navigation capabilities on the whole planet; such data, weighs about 50GB, thus it is recommended to use an extract with the data relative to the interested area. One great way to obtain an extract is through \href{https://extract.bbbike.org/}{\textit{BBBike}} \cite{Pianini_2013}.

Once extracted the map in the \texttt{.pbf} format, it is possible to build the simulation environment through the \href{https://alchemistsimulator.github.io/reference/kdoc/alchemist/it.unibo.alchemist.model.implementations.environments/-o-s-m-environment/}{\texttt{OSMEnvornment}}, as shown in the following listing (\ref{code:osm}).

\begin{lstlisting}[language=yaml, label=code:osm, caption=Building an \textit{OpenStreetMap} environment.]
# Use an OpenStreetMap Environment,
# deploying nodes only on streets.
environment:
  type: OSMEnvironment
  parameters: [mirabilandia.osm.pbf, true]
\end{lstlisting}

\noindent
The constructor of the environment accepts two parameters:
\begin{itemize}
    \item \texttt{file: String}, the path to the file containing the exported map;
    \item \texttt{onlyOnStreets: Boolean}, a boolean value allowing to deploy nodes only on the streets.
\end{itemize}

\subsection{Deployed Nodes}
After setting the environment, it is essential to deploy \textbf{nodes} on the map. In the current simulation, the elements that are represented by nodes are:
\begin{itemize}
    \item \textbf{Visitors}, as single individuals or groups; the key point here is that a node should correspond to one or more people using a single wearable device that tracks and guides its carrier.
    \item \textbf{Attractions}, that can be of different types, such as rides, water slides, restaurants, etc.; they are considered \textit{rendesvouz} points for visitors and are made of several sensors that allow to keep track of many information, such as the number of people waiting in a queue.
\end{itemize}

\noindent
In order to deploy nodes on the map it is mandatory to declare them under the \texttt{deployment} keyword, as shown in the following listing.

\begin{lstlisting}[language=yaml, label=code:deployment, caption=Deploying 1 attraction and 100 visitors inside the \texttt{bounds} polygon.]
# Define visitors
_visitors: &visitors
  - type: Polygon
    parameters: [ 100, *bounds ]
    contents:
      - { molecule: visitor, concentration: true }

# Define attractions
_attractions: &attractions
  - type: Point
    parameters: [44.33589, 12.26293]
    contents:
      - { molecule: attraction, concentration: true }
      - { molecule: attractionType, concentration: "\"restaurant\"" }
      - { molecule: capacity, concentration: 10 }
      - { molecule: name, concentration: "\"McDonald's\"" }

# Deploy nodes
deployments:
  - *attractions
  - *visitors
\end{lstlisting}

\noindent
Moreover, it is necessary to explicit which \textbf{linking rule} will be used to connect nodes with each other. As for the current simulation, the proper way to connect nodes cannot be based on a geometric rule (for instance, connecting nodes within a certain distance). Instead, it is appropriate to consider attractions as \textbf{access points} for the visitors' devices. Even with the \href{https://alchemistsimulator.github.io/reference/kdoc/alchemist/it.unibo.alchemist.model.implementations.linkingrules/-connect-to-access-point/index.html}{\texttt{ConnectToAccessPoint}} linking rule every node on the map will be connected with the rest of the network as the attractions are distributed throughout the map, and, working as access points, they can cover it without leaving connectionless areas.

\begin{lstlisting}[language=yaml, label=code:linking, caption=Defining the linking rule: only nodes with the molecule \texttt{attraction} will connect to other nodes within a radius of 100 meters.]
# The network model used allows to choose the nodes that have the
# "attraction" molecule in order to simulate an access point behaviour
network-model:
  type: ConnectToAccessPoint
  parameters: [100.0, "attraction"]
\end{lstlisting}

\subsection{Programmed Behaviours}
With the environment and the nodes set, the next step consists in programming their behaviours.
Each and every node needs to implement a proper behaviour depending on its type.
In particular, visitors and attractions will have different behaviours: for instance, visitors should move on the map in order to get to attractions, while the latter should stay still and satisfy enqueued visitors.
The following sections describe the behaviours implemented by visitors and attractions.

\subsubsection{Attractions' Positions}
In order to make each visitor node aware of the positions of all the attractions in the map, it is necessary to implement a behaviour that spreads the desired information. To do so, it is useful to use \textit{aggregate programming}.
Specifically, \textit{Alchemist} allows inserting an external program into a node, as shows the following listing.

\begin{lstlisting}[language=yaml, label=code:positions, caption=Assign the \texttt{org:protelis:microcity:positions} behaviour to 100 visitors and 2 attractions.]
# Define the broadcast message from attractions to visitors
# to spread their positions
_positions: &positions
  - time-distribution: 1
    program: org:protelis:microcity:positions
  - program: send

# Define visitors
_visitors: &visitors
  - type: Polygon
    parameters: [ 100, *bounds ]
    programs: *positions
    contents:
      - { molecule: visitor, concentration: true }

# Define attractions
_attractions: &attractions
  - type: Point
    parameters: [44.33747, 12.26208]
    programs: *positions
    contents:
      - { molecule: attraction, concentration: true }
  - type: Point
    parameters: [ 44.33815, 12.2633 ]
    programs: *positions
    contents:
      - { molecule: attraction, concentration: true }
\end{lstlisting}

On the other hand, the definition of the aggregate program should describe how the desired information is spread around as a field.
In particular, each node should gather the field from its neighbours and merge the received values. The listing \ref{} shows how it is possible to implement this behaviour in \textit{Protelis}.

\begin{lstlisting}[label=code:protelis-positions, caption=Sharing the coordinates of each attraction to all the nodes that implement this behaviour.]
module org:protelis:microcity:positions

import microcity.Positions.attractionPositions
import microcity.Positions.attractionUnion

share (field <- attractionPositions()) {
    foldHoodPlusSelf(field, { a, b -> attractionUnion(a, b) })
}
\end{lstlisting}

The \texttt{attractionPositions} function simply builds a list with the node's position if it owns an "attraction" molecule, otherwise an empty list.
In this way, the field is composed by lists of positions containing only attractions' coordinates. The \texttt{attractionUnion} function just unifies the received lists into a single one.

\subsubsection{Queues \& Satisfaction}
Similarly to positions, it is necessary to keep track of the queues that form nearby attractions and spread them to visitors.
The queue formed nearby an attraction is determined by the set of visitors that have the same coordinates as the attraction.
Though, it is important that the visitors waiting in the queue are not satisfied.
In fact, a visitor's satisfaction is a condition that only occurs after it has benefitted from an attraction.
When satisfied, the visitor is then ready to choose the next destination, and, once the next attraction is decided, it can turn back to unsitisfied.
These behaviours can be split up into 3 different \textit{Protelis} programs:
\begin{itemize}
  \item \textbf{\texttt{queue}}: given an attraction, determine the list of visitors that are enqueued to it.
  \item \textbf{\texttt{queues}}: spread the queues of every attraction to every visitor.
  \item \textbf{\texttt{satisfaction}}: given an attraction, satisfy the first $N$ visitors in its queue, where $N$ stands for the attraction's capacity.
\end{itemize}

\noindent
All these behaviours are programmed by both attractions and visitors.
The \texttt{satisfaction} program has a lower time distribution, as it is assumed that it takes a while for an attraction to satisfy visitors.

\subsubsection{Movement}
Movement is a feature only owned by visitors. It is implemented as a \href{https://alchemistsimulator.github.io/reference/kdoc/alchemist/it.unibo.alchemist.model.implementations.actions/-target-map-walker/index.html}{\texttt{TargetMapWalker}}: this action needs a "tracking" molecule inside the implementing node that has a destination's coordinates as its concentration.
Moreover, the latter allows nodes to move only on street maps, sticking with the provided \href{https://alchemistsimulator.github.io/reference/kdoc/alchemist/it.unibo.alchemist.model.implementations.environments/-o-s-m-environment/}{\texttt{OSMEnvornment}}.

As discussed in the section \ref{sec:the-case-study}, in order to decide its next destination, a visitor can adapt one of two policies: \textbf{Random Redirection} or \textbf{Recommended Redirection}. For this, visitors also own a program that establishes the next destination with one of the two policies and inserts its coordinates in a molecule. The listings \ref{code:movement}

\begin{lstlisting}[language=yaml, label=code:movement, caption=Define the movement behaviour for visitors.]
# Define the movement law with a Walker that moves only on streets towards
# a GeoPosition indicated by the concentration of the tracking molecule
_move: &move
  - time-distribution: 1
    type: Event
    actions:
      - type: TargetMapWalker
        parameters: [org:protelis:microcity:destination, 1.0]

# Define the rule that establishes how visitors choose the
# next destination
_destination: &destination
  - time-distribution: 1
    program: org:protelis:microcity:destination
  - program: send
\end{lstlisting}

\subsection{Data Extraction}